```
(define (square x) (* x x))

(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                 x)))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(define (good-enough? guess x)
  (< (abs (- (square guess) x)) 0.001))
```

Our `good-enough?` procedure isn't very effective for small numbers because, as
the number we're taking the root of gets smaller, any guess whose square is
less than 0.001 becomes "good enough". This is because the square of the guess
is within 0.001 of all numbers from 0 to 0.001:

We've decided that a guess is good enough when its square is within 0.001 of
the number we're given (x). When x is very small (less than 0.001), our sqrt
procedure stops once the square of the guess is about 0.001, since the guess is
now good enough for any number between 0 and 0.001.

eg. if we square our square root approximation, we expect to get the original
number back, within our threshold of 0.001 (since that's what we've decided
`good-enough?` should check). Trying this with successively smaller powers of
10, we see that, once the original number gets smaller than 0.001, the result
is approximately 0.001 regardless of what the original number was:

```
> (square (sqrt 0.1))
0.10001125566203942
> (square (sqrt 0.01))
0.01006526315785885
> (square (sqrt 0.001))
0.0017011851721075596
> (square (sqrt 0.0001))
0.0010438358335233748
> (square (sqrt 0.00001))
0.0009832294718753643
> (square (sqrt 0.000001))
0.0009772285838805523
> (square (sqrt 0.0000001))
0.000976629102245155
> (square (sqrt 0.00000001))
0.000976569160163076
```

Note: for numbers less than 0.001, our square root approximation doesn't
necessarily return a number whose square is less than 0.001, just a number
that's approximately 0.001. As seen in the example above for 0.0001, even
though the number is less than 0.001, the square of the root we find is greater
than 0.001. This is just because it's the first guess we find that's within
0.001 of the original number.

________________________________________________________________________________

Here we use an updated version of `improve` to show the intermediate guesses:

```
(define (improve guess x)
  (begin
    (println guess)
    (average guess (/ x guess))))
```

Our `good-enough?` procedure is inadequate for large numbers because we need to
have enough precision to represent numbers smaller than 0.001 in the result of
our subtraction `(- (square guess) x)`. When x is large enough, this subtraction
ends up always producing a number greater than 0.001.

To represent a reasonable approximation of 0.001 as a floating point binary
number, we need to at least be able to represent 2**-10. This means we need at
least 10 binary digits for negative powers of 2. IEEE 754 floating point
numbers (the standard used in most computers) have 53 significant binary digits
in their significand, so if we need 10 of these for negative exponents, we only
have 43 left for non-negative ones. This means we can represent 0.001* in any
large floating point number less than 2**43:

```
> (+ 0.001 (- (expt 2.0 43) 1))
8796093022207.001
> (+ 0.001 (expt 2.0 43))
8796093022208.002
> (+ 0.001 (- (expt 2.0 44) 1))
17592186044415.002
> (+ 0.001 (expt 2.0 44))
17592186044416.0
```

2**43 is the smallest number that requires 44 binary digits for non-negative
powers of 2, leaving only 9 digits for negative powers, which isn't enough to
represent 2**-10.

Without at least 10 digits for negative powers of 2, the subtraction in our
`good-enough?` function can only produce either 0 or at least 2**-9: we can't
represent a number in between.  If the subtraction gives us 0, we consider the
guess good enough and our program halts. If it doesn't give us 0, we try to
improve it. Either the improvements eventually give us 0 for our subtraction
(so that our guess is good enough), or we end up getting the same number back
from `improve` (we find a fixed point of improve) that still gives us a
non-zero difference, and our program never halts.

Once the square of our guess is large enough or the guess is a fixed point of
`improve` and its square is more than 0.001 from x, we loop infinitely. The
square of our guess is too far from x and we don't have enough precision for
`improve` to bring it closer.

\* really 1/1024, but that's a fairly good approximation, as the next digit is
2**-16, or 1/65536

12345678901234 doesn't terminate, as successive applications of improve lead to
a fixed point of improve whose square is greater than 0.001 from 12345678901234:

```
> (sqrt 12345678901234.0)
1.0
6172839450617.5
3086419725309.75
1543209862656.875
771604931332.4375
385802465674.21875
192901232853.10938
96450616458.55469
48225308293.27734
24112654274.63867
12056327393.319334
6028164208.659653
3014083128.3297105
1507043612.1639276
753525902.074542
376771142.9778979
188401955.01397642
94233741.7076047
47182376.47141617
23722017.581583798
12121224.408177208
6569870.942541849
4224503.311279173
3573450.5222935397
3514142.3366335463
3513641.86446291
3513641.8288200637
3513641.8288200637
...
> (square 3513641.8288200637)
12345678901234.002
```

________________________________________________________________________________

```
(define (new-sqrt-iter old-guess new-guess x)
  (if (new-good-enough? old-guess new-guess)
      new-guess
      (new-sqrt-iter new-guess
                     (improve new-guess x)
                     x)))

(define (new-sqrt x)
  (new-sqrt-iter 0.0 1.0 x))

(define (new-good-enough? old-guess new-guess)
  (< (abs (- old-guess new-guess)) 0.001))
```
